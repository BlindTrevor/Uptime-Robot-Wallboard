<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Status Wallboard – UptimeRobot (v3)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta http-equiv="Cache-Control" content="no-store" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" integrity="sha512-DTOQO9RWCH3ppGqcWaEA1BIZOC6xxalwEsw9c2QQeAIftl+Vegovlnee1c9QX4TctnWMn13TZye+giMm8e2LwA==" crossorigin="anonymous">
  <style>
    /* Dark theme (default) */
    :root {
      --bg: #0b1220;
      --card: #121c33;
      --border: #213155;
      --accent: #3a569c;
      --text: #e8eefc;
      --subtle: #9fb0d1;
      --muted: #b9c6e2;
      --ok: #3ad29f;
      --warn: #ffd27a;
      --bad: #ff6b6b;
      --bg-offline: #2a1515;
      --card-offline: #331a1a;
      --border-offline: #5e2323;
    }

    /* Light theme */
    [data-theme="light"] {
      --bg: #f5f7fa;
      --card: #ffffff;
      --border: #d1d9e6;
      --accent: #4a6fa5;
      --text: #1a2332;
      --subtle: #5a6c85;
      --muted: #6b7b95;
      --ok: #28a745;
      --warn: #fd7e14;
      --bad: #dc3545;
      --bg-offline: #fff5f5;
      --card-offline: #ffe5e5;
      --border-offline: #ffcccc;
    }
    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0; padding: 1rem;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: var(--bg); color: var(--text);
      transition: background 0.3s ease;
      will-change: background;
    }
    body.has-offline { background: var(--bg-offline); }
    header { display: flex; flex-wrap: wrap; align-items: center; gap: 10px; }
    .header-content { display: flex; align-items: center; gap: 15px; flex-wrap: wrap; }
    .logo { height: 50px; max-width: 400px; width: auto; object-fit: contain; }
    h1 { margin: 0 1rem 0 0; font-size: 1.25rem; }
    .meta { color: var(--subtle); }
    .row { display: flex; align-items: center; gap: 10px; flex-wrap: wrap; }
    .controls { margin: 0.6rem 0 0.8rem; display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      background: var(--border); color: var(--text);
      border: 1px solid var(--accent); border-radius: 8px;
      padding: 6px 10px; cursor: pointer; font-weight: 600;
    }
    button:hover { background: #274071; }
    .pill {
      display: inline-flex; align-items: center; gap: 6px;
      padding: 2px 10px; border-radius: 999px; font-size: 0.85rem;
      border: 1px solid var(--border);
    }
    .pill.warn { background: #3b2a1a; color: var(--warn); border-color: #5e4123; }
    .pill.ok { background: #163327; color: #8af0c9; border-color: #184836; }
    .grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(320px, 1fr)); gap: 12px; }
    .card { background: var(--card); border: 1px solid var(--border); border-radius: 10px; padding: 12px; }
    .card.offline { background: var(--card-offline); border-color: var(--border-offline); }
    .name { font-weight: 700; font-size: 1.05rem; margin-bottom: 6px; }
    .url { color: var(--subtle); font-size: 0.9rem; word-break: break-word; }
    .status { margin-top: 8px; font-weight: 800; letter-spacing: 0.4px; display: flex; align-items: center; gap: 6px; }
    .status i { font-size: 1.1em; }
    .status.up { color: var(--ok); }
    .status.seems_down, .status.down { color: var(--bad); }
    .status.paused { color: var(--warn); }
    .status.not_checked { color: var(--subtle); }
    .kv { font-size: 0.86rem; color: var(--muted); margin-top: 6px; }
    .small { font-size: 0.78rem; color: var(--subtle); margin-top: 6px; }
    .err { color: var(--bad); margin: 0.4rem 0; white-space: pre-wrap; }
    .footer { color: var(--subtle); margin-top: 0.5rem; font-size: 0.85rem; }
    
    /* 24-hour status visualization */
    .status-24h { margin-top: 10px; }
    .status-24h-title { 
      font-size: 0.8rem; 
      color: var(--subtle); 
      margin-bottom: 4px;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .status-24h-uptime { 
      font-weight: 700;
      color: var(--text);
    }
    .status-24h-bars {
      display: flex;
      gap: 2px;
      height: 32px;
      margin-bottom: 6px;
    }
    .status-24h-bar {
      flex: 1;
      border-radius: 3px;
      transition: opacity 0.2s;
    }
    .status-24h-bar.up {
      background: var(--ok);
    }
    .status-24h-bar.down {
      background: var(--bad);
    }
    .status-24h-bar.unknown {
      background: var(--border);
    }
    .status-24h-bar:hover {
      opacity: 0.8;
    }
    .status-24h-summary {
      font-size: 0.8rem;
      color: var(--muted);
    }
  </style>
</head>
<body>
  <header>
    <div class="header-content">
      <img id="logo" class="logo" style="display:none" alt="Logo" />
      <h1 id="title">UptimeRobot – Current Status</h1>
    </div>
    <div class="meta row">
      <span id="last-updated">Last updated: —</span>
      <span id="problem-pill" class="pill" style="display:none"></span>
    </div>
  </header>

  <div class="controls">
    <button id="toggle-problems">Show Only Problems</button>
    <button id="refresh-btn">Refresh Now</button>
    <button id="theme-toggle"><i class="fas fa-sun"></i> Light Mode</button>
  </div>

  <div id="error" class="err"></div>
  <div id="grid" class="grid"></div>
  <div id="footer" class="footer"></div>

  <script>
    // --- Configuration ---
    const ENDPOINT = '/status/uptimerobot_status.php'; // adjust if you host elsewhere
    const CONFIG_VERSION_ENDPOINT = '/status/config_version.php'; // endpoint to check config changes
    
    // Default configuration (will be overridden by server config and/or query string)
    let config = {
      refreshRate: 20,
      configCheckRate: 5,
      showProblemsOnly: false,
      allowQueryOverride: true,
      theme: 'dark', // 'dark', 'light', or 'auto'
    };

    // --- Theme Management ---
    // Cookie utilities
    const COOKIE_EXPIRY_DAYS = 365;
    const MS_PER_DAY = 864e5; // Milliseconds in a day
    
    function setCookie(name, value, days = COOKIE_EXPIRY_DAYS) {
      const expires = new Date(Date.now() + days * MS_PER_DAY).toUTCString();
      document.cookie = name + '=' + encodeURIComponent(value) + '; expires=' + expires + '; path=/; SameSite=Lax';
    }

    function getCookie(name) {
      return document.cookie.split('; ').reduce((r, v) => {
        const parts = v.split('=');
        return parts[0] === name ? decodeURIComponent(parts[1]) : r;
      }, '');
    }

    // Get system preference
    function getSystemTheme() {
      return window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    }

    // Apply theme to document
    function applyTheme(theme) {
      const resolvedTheme = theme === 'auto' ? getSystemTheme() : theme;
      document.documentElement.setAttribute('data-theme', resolvedTheme);
      
      // Update button text and icon
      const themeBtn = document.getElementById('theme-toggle');
      if (themeBtn) {
        if (resolvedTheme === 'light') {
          themeBtn.innerHTML = '<i class="fas fa-moon"></i> Dark Mode';
        } else {
          themeBtn.innerHTML = '<i class="fas fa-sun"></i> Light Mode';
        }
      }
      
      return resolvedTheme;
    }

    // Initialize theme from cookie, config, or system preference
    function initializeTheme() {
      // Priority: cookie > query string > config > auto (system preference)
      const cookieTheme = getCookie('theme');
      const queryTheme = new URLSearchParams(window.location.search).get('theme');
      
      let selectedTheme = config.theme || 'auto';
      
      // Apply query string if allowed and present
      if (config.allowQueryOverride && queryTheme && ['dark', 'light', 'auto'].includes(queryTheme)) {
        selectedTheme = queryTheme;
      }
      
      // Cookie overrides everything (user's explicit choice)
      if (cookieTheme && ['dark', 'light', 'auto'].includes(cookieTheme)) {
        selectedTheme = cookieTheme;
      }
      
      applyTheme(selectedTheme);
    }

    // Toggle theme
    function toggleTheme() {
      const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
      const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
      applyTheme(newTheme);
      setCookie('theme', newTheme);
    }

    // Listen for system theme changes when in auto mode
    if (window.matchMedia) {
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
        const cookieTheme = getCookie('theme');
        if (!cookieTheme || cookieTheme === 'auto') {
          applyTheme('auto');
        }
      });
    }
    
    // Parse query string parameters
    function parseQueryString() {
      const params = new URLSearchParams(window.location.search);
      const queryConfig = {};
      
      // Parse showProblemsOnly
      if (params.has('showProblemsOnly')) {
        queryConfig.showProblemsOnly = params.get('showProblemsOnly') === 'true';
      }
      
      // Parse theme
      if (params.has('theme')) {
        const theme = params.get('theme');
        if (['dark', 'light', 'auto'].includes(theme)) {
          queryConfig.theme = theme;
        }
      }
      
      // Parse refreshRate (in seconds, minimum 10)
      if (params.has('refreshRate')) {
        const rate = parseInt(params.get('refreshRate'), 10);
        if (!isNaN(rate) && rate >= 10) {
          queryConfig.refreshRate = rate;
        }
      }
      
      // Parse configCheckRate (in seconds, minimum 1)
      if (params.has('configCheckRate')) {
        const rate = parseInt(params.get('configCheckRate'), 10);
        if (!isNaN(rate) && rate >= 1) {
          queryConfig.configCheckRate = rate;
        }
      }
      
      return queryConfig;
    }
    
    // Apply configuration from server and query string
    function applyConfiguration(serverConfig) {
      // Start with server config
      if (serverConfig) {
        if (typeof serverConfig.showProblemsOnly === 'boolean') {
          config.showProblemsOnly = serverConfig.showProblemsOnly;
        }
        if (typeof serverConfig.refreshRate === 'number') {
          config.refreshRate = serverConfig.refreshRate;
        }
        if (typeof serverConfig.configCheckRate === 'number') {
          config.configCheckRate = serverConfig.configCheckRate;
        }
        if (typeof serverConfig.allowQueryOverride === 'boolean') {
          config.allowQueryOverride = serverConfig.allowQueryOverride;
        }
        if (typeof serverConfig.theme === 'string' && ['dark', 'light', 'auto'].includes(serverConfig.theme)) {
          config.theme = serverConfig.theme;
        }
      }
      
      // Apply query string overrides if allowed
      if (config.allowQueryOverride) {
        const queryConfig = parseQueryString();
        Object.assign(config, queryConfig);
      }
      
      // Re-initialize theme after server configuration is applied
      // This respects the priority: cookie > query string > server config
      initializeTheme();
    }

    // State
    let onlyProblems = false;
    let lastStatuses = new Map(); // id -> previous status (for change detection)
    let currentConfigVersion = null; // Track config file version
    let refreshInterval = null;
    let configCheckInterval = null;
    let initialConfigApplied = false; // Flag to prevent race conditions on initial load

    // Utilities
    function epochToLocal(epoch) {
      const n = Number(epoch);
      if (!n) return '—';
      const d = new Date(n * 1000);
      return isNaN(d.getTime()) ? '—' : d.toLocaleString();
    }
    const toClass = s => (s || 'unknown').toLowerCase().replace(/\s+/g, '_');

    function getStatusIcon(status) {
      const s = (status || '').toLowerCase();
      switch (s) {
        case 'up':
          return '<i class="fas fa-check-circle"></i>';
        case 'down':
        case 'seems_down':
          return '<i class="fas fa-times-circle"></i>';
        case 'paused':
          return '<i class="fas fa-pause-circle"></i>';
        default:
          return '<i class="fas fa-question-circle"></i>';
      }
    }

    function formatTags(tags) {
      if (!Array.isArray(tags) || !tags.length) return '';
      return tags
        .map(t => typeof t === 'object' && t !== null ? (t.name || '') : t)
        .filter(Boolean)
        .join(', ');
    }

    function isProblem(m) {
      const s = (m.status || '').toLowerCase();
      return s !== 'up';
    }

    // Constants for 24-hour status visualization
    const UPTIME_THRESHOLD_PERCENT = 50; // Consider >= 50% uptime as "up"
    const SECONDS_PER_HOUR = 3600;

    // Process lastDayUptimes histogram data for 24-hour visualization
    function process24HourData(lastDayUptimes, incidents24h) {
      if (!lastDayUptimes || !lastDayUptimes.histogram || !Array.isArray(lastDayUptimes.histogram)) {
        return null;
      }
      
      const histogram = lastDayUptimes.histogram;
      
      // Get the most recent 24 hours of data
      const hourlyData = histogram.slice(-24);
      
      // Calculate statistics
      let totalUptime = 0;
      let incidentCount = 0;
      let totalDowntimeSeconds = 0;
      
      // Use actual incidents count if available, otherwise detect from histogram transitions
      if (incidents24h && Array.isArray(incidents24h) && incidents24h.length > 0) {
        incidentCount = incidents24h.length;
      } else {
        // Fallback: detect incidents from histogram transitions
        let lastStatus = null;
        hourlyData.forEach((hour, index) => {
          const uptime = parseFloat(hour.uptime) || 0;
          const currentStatus = uptime >= UPTIME_THRESHOLD_PERCENT ? 'up' : 'down';
          
          // Initialize with first hour status
          if (index === 0) {
            lastStatus = currentStatus;
            // If first hour is down, count it as an incident (ongoing from before window)
            if (currentStatus === 'down') {
              incidentCount++;
            }
          } else if (lastStatus === 'up' && currentStatus === 'down') {
            // Detected a transition from up to down
            incidentCount++;
          }
          
          lastStatus = currentStatus;
        });
      }
      
      hourlyData.forEach((hour, index) => {
        const uptime = parseFloat(hour.uptime) || 0;
        totalUptime += uptime;
        
        // Calculate downtime in seconds (assuming 1-hour intervals)
        const downtimePercent = 100 - uptime;
        totalDowntimeSeconds += (downtimePercent / 100) * SECONDS_PER_HOUR;
      });
      
      const avgUptime = hourlyData.length > 0 ? totalUptime / hourlyData.length : 0;
      
      return {
        hourlyData: hourlyData,
        uptimePercent: avgUptime.toFixed(3),
        incidentCount: incidentCount,
        totalDowntimeSeconds: Math.round(totalDowntimeSeconds)
      };
    }
    
    // Format downtime duration
    function formatDowntime(seconds) {
      if (seconds === 0) return '0s';
      
      const hours = Math.floor(seconds / SECONDS_PER_HOUR);
      const minutes = Math.floor((seconds % SECONDS_PER_HOUR) / 60);
      const secs = seconds % 60;
      
      const parts = [];
      if (hours > 0) parts.push(`${hours}h`);
      if (minutes > 0) parts.push(`${minutes}m`);
      if (secs > 0 || parts.length === 0) parts.push(`${secs}s`);
      
      return parts.join(', ');
    }
    
    // Get status class for a given uptime percentage
    function getHourStatusClass(uptime) {
      if (uptime >= UPTIME_THRESHOLD_PERCENT) return 'up';
      if (uptime > 0) return 'down';
      return 'unknown';
    }
    
    // Render 24-hour status visualization
    function render24HourStatus(monitor) {
      const data = process24HourData(monitor.last_day_uptimes, monitor.incidents_24h);
      
      if (!data) {
        return ''; // No data available
      }
      
      // Generate 24 bars with relative time labels
      const bars = data.hourlyData.map((hour, index) => {
        const uptime = parseFloat(hour.uptime) || 0;
        const statusClass = getHourStatusClass(uptime);
        const hoursAgo = data.hourlyData.length - index - 1;
        const timeLabel = hoursAgo === 0 ? 'Current hour' : `${hoursAgo} hour${hoursAgo === 1 ? '' : 's'} ago`;
        const title = `${timeLabel}: ${uptime.toFixed(1)}% uptime`;
        return `<div class="status-24h-bar ${statusClass}" title="${title}"></div>`;
      }).join('');
      
      const summaryText = `${data.incidentCount} incident${data.incidentCount === 1 ? '' : 's'}, ${formatDowntime(data.totalDowntimeSeconds)} down`;
      
      return `
        <div class="status-24h">
          <div class="status-24h-title">
            <span>Last 24 hours</span>
            <span class="status-24h-uptime">${data.uptimePercent}%</span>
          </div>
          <div class="status-24h-bars">
            ${bars}
          </div>
          <div class="status-24h-summary">${summaryText}</div>
        </div>
      `;
    }

    // Fetch
    async function loadData() {
      const params = new URLSearchParams();
      if (onlyProblems) params.set('only_problems', '1');

      const url = ENDPOINT + (params.toString() ? ('?' + params.toString()) : '');
      const res = await fetch(url, { cache: 'no-store' });
      const text = await res.text(); // read once
      if (!res.ok) {
        throw new Error(`HTTP ${res.status}: ${text}`);
      }
      try {
        return JSON.parse(text);
      } catch (e) {
        throw new Error(`Invalid JSON: ${e.message}\nBody: ${text.slice(0, 400)}${text.length > 400 ? '…' : ''}`);
      }
    }

    // Render
    function render(data) {
      const grid = document.getElementById('grid');
      const err = document.getElementById('error');
      const last = document.getElementById('last-updated');
      const pill = document.getElementById('problem-pill');
      const footer = document.getElementById('footer');
      const title = document.getElementById('title');
      const logo = document.getElementById('logo');

      // Apply configuration from server
      if (data.config) {
        applyConfiguration(data.config);
        
        // Apply showProblemsOnly from config on first load only
        if (!initialConfigApplied) {
          initialConfigApplied = true;
          onlyProblems = config.showProblemsOnly;
          document.getElementById('toggle-problems').textContent = onlyProblems ? 'Show All' : 'Show Only Problems';
        }
        
        if (data.config.title) {
          // Use textContent (not innerHTML) to prevent XSS
          title.textContent = data.config.title;
          document.title = data.config.title;
        }
        if (data.config.logo) {
          // Validate logo URL/path before setting
          const logoPath = data.config.logo;
          // Allow: relative paths ending in image extensions, http/https URLs, data URIs
          // Block: javascript:, file:, and other potentially dangerous schemes
          const isValidUrl = /^https?:\/\/.+\.(png|jpg|jpeg|gif|svg|webp)$/i.test(logoPath);
          const isValidPath = /^[a-zA-Z0-9_\/.-]+\.(png|jpg|jpeg|gif|svg|webp)$/i.test(logoPath) && !logoPath.includes('..');
          // Data URIs are limited to 100KB to prevent abuse
          const isDataUri = /^data:image\/(png|jpg|jpeg|gif|svg\+xml|webp);base64,/i.test(logoPath) && logoPath.length < 102400;
          
          if (isValidUrl || isValidPath || isDataUri) {
            logo.src = logoPath;
            logo.style.display = 'block';
            // Handle image load errors
            logo.onerror = function() {
              console.warn('Failed to load logo:', logoPath);
              logo.style.display = 'none';
            };
          } else {
            console.warn('Invalid logo path:', logoPath);
          }
        } else {
          logo.style.display = 'none';
        }
      }

      err.textContent = '';
      last.textContent = `Last updated: ${new Date().toLocaleString()}`;

      let mons = Array.isArray(data.monitors) ? data.monitors.slice() : [];

      // Sort: problems first, then by name
      mons.sort((a, b) => {
        const ap = isProblem(a), bp = isProblem(b);
        if (ap !== bp) return ap ? -1 : 1;
        return (a.friendly_name || '').localeCompare(b.friendly_name || '');
      });

      // Problem count pill
      const problemCount = mons.filter(isProblem).length;
      if (problemCount > 0) {
        pill.style.display = 'inline-flex';
        pill.className = 'pill warn';
        pill.innerHTML = `<i class="fas fa-exclamation-triangle"></i><span>${problemCount} issue${problemCount === 1 ? '' : 's'}</span>`;
      } else {
        pill.style.display = 'inline-flex';
        pill.className = 'pill ok';
        pill.innerHTML = '<i class="fas fa-check"></i><span>All good</span>';
      }

      // Update body background based on offline status
      if (problemCount > 0) {
        document.body.classList.add('has-offline');
      } else {
        document.body.classList.remove('has-offline');
      }

      // Build cards
      grid.innerHTML = mons.map(m => {
        const cls = `status ${toClass(m.status)}`;
        const statusIcon = getStatusIcon(m.status);
        const isOffline = isProblem(m);
        const cardClass = isOffline ? 'card offline' : 'card';
        // Prefer custom ratios if present, otherwise all-time
        const ratios = m.custom_uptime_ratios
          ? `${m.custom_uptime_ratios}% (1/7/30/90d)`
          : (m.all_time_uptime_ratio ? `${m.all_time_uptime_ratio}% (all-time)` : '—');
        const tags = formatTags(m.tags);
        const status24h = render24HourStatus(m);

        return `
          <div class="${cardClass}">
            <div class="name">${m.friendly_name || '—'}</div>
            <div class="url">${m.url || '—'}</div>
            <div class="${cls}">${statusIcon}${(m.status || 'UNKNOWN').toUpperCase()}</div>
            ${status24h}
            <div class="kv">Last check: ${epochToLocal(m.last_check)} | Next: ${epochToLocal(m.next_check)}</div>
            <div class="kv">Uptime: ${ratios}</div>
            ${tags ? `<div class="small">Tags: ${tags}</div>` : ''}
          </div>
        `;
      }).join('');

      // Footer (optionally show pagination meta if sent)
      if (data.meta && (data.meta.next_cursor || data.meta.prev_cursor)) {
        footer.textContent = `Page size: ${mons.length} — Cursor: next=${data.meta.next_cursor || '∅'}`;
      } else {
        footer.textContent = '';
      }

      // Track status changes (you can add audio/visual cues here)
      const changes = [];
      for (const m of mons) {
        const prev = lastStatuses.get(m.id);
        if (prev && prev !== m.status) {
          changes.push({ id: m.id, name: m.friendly_name, from: prev, to: m.status });
        }
        lastStatuses.set(m.id, m.status);
      }
      // Example: simple console log on state change
      if (changes.length) {
        console.log('State changes:', changes);
      }
    }

    async function refresh() {
      const err = document.getElementById('error');
      try {
        const data = await loadData();
        if (!data.ok) throw new Error(data.error || 'Unknown error');
        render(data);
      } catch (e) {
        err.textContent = 'Error: ' + e.message;
      }
    }

    // Check if config has changed
    async function checkConfigVersion() {
      try {
        const res = await fetch(CONFIG_VERSION_ENDPOINT, { cache: 'no-store' });
        if (!res.ok) return; // Silently fail, don't disrupt user experience
        
        const data = await res.json();
        if (data.ok && data.version) {
          if (currentConfigVersion === null) {
            // First load, just store the version
            currentConfigVersion = data.version;
          } else if (currentConfigVersion !== data.version) {
            // Config has changed! Refresh the wallboard
            console.log('Config file changed, refreshing wallboard...');
            currentConfigVersion = data.version;
            await refresh();
          }
        }
      } catch (e) {
        // Silently fail - config checking is a convenience feature
        // Don't disrupt the main wallboard functionality
        console.warn('Config version check failed:', e.message);
      }
    }

    // Update intervals based on configuration
    function updateIntervals() {
      // Clear existing intervals
      if (refreshInterval) {
        clearInterval(refreshInterval);
        refreshInterval = null;
      }
      if (configCheckInterval) {
        clearInterval(configCheckInterval);
        configCheckInterval = null;
      }
      
      // Set new intervals based on config
      refreshInterval = setInterval(refresh, config.refreshRate * 1000);
      configCheckInterval = setInterval(checkConfigVersion, config.configCheckRate * 1000);
    }

    // Events
    document.getElementById('refresh-btn').addEventListener('click', refresh);
    document.getElementById('toggle-problems').addEventListener('click', () => {
      onlyProblems = !onlyProblems;
      document.getElementById('toggle-problems').textContent = onlyProblems ? 'Show All' : 'Show Only Problems';
      refresh();
    });
    document.getElementById('theme-toggle').addEventListener('click', toggleTheme);

    // Initial load + polling
    refresh().finally(() => {
      // After first refresh (success or failure), update intervals based on loaded config
      updateIntervals();
    });
    
    // Initialize config version checking
    checkConfigVersion();

    // Initialize theme early (before first data load) with default config
    initializeTheme();
  </script>
</body>
</html>
